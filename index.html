<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords" content="HyyypRtf06, HyyypRtf06's Blog"><meta name="author" content="HyyypRtf06"><meta name="description" content><meta name="copyright" content="HyyypRtf06"><title>using namespace AFO; | HyyypRtf06's Blog</title><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=1.2.5" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=1.2.5" type="image/png" sizes="32x32"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=1.2.5"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  sidebar: {"offsetTop":"20px"},
  back2top: {"enable":true,"animation":true},
  reward: false,
  fancybox: false,
  zoom_image: {"enable":true,"mask_color":"rgba(0,0,0,0.6)"},
  gallery_waterfall: undefined,
  lazyload: undefined,
  external_link: {"icon":{"enable":true,"name":"external-link"}},
  shortcuts: {"switch_post":false},
  prompt: {"copy_success":"复制成功","copy_error":"复制失败","creative_commons":"知识共享","copy_code":"复制代码"}
};

window.CONFIG = CONFIG;</script></head><body><div id="container"><header id="header" style="background-image: url( )"><nav class="header-nav slider-up"><div class="header-nav-inner"><div class="fa fa-bars header-nav-menu-icon"></div><div class="header-nav-menu"><div class="menu-item"><a class="menu-item-inner" href="/"><i class="fa fa-home"></i>首页</a></div><div class="menu-item"><a class="menu-item-inner" href="/archives/"><i class="fa fa-folder-open"></i>归档</a></div></div></div></nav><div class="header-info"><div class="header-info-inner"><div class="header-info-title">HyyypRtf06's Blog</div><div class="header-info-subtitle">using namespace AFO;</div></div></div></header><main id="main"><div class="main-inner"><aside id="sidebar"><div class="sidebar-inner"><section class="hide sidebar-toc"></section><section class="sidebar-overview"><div class="sidebar-author"><img class="sidebar-author-avatar" src="/images/avatar.png" alt="avatar"><p class="sidebar-author-motto">hello world</p></div><div class="sidebar-state"><span class="sidebar-state-item sidebar-state-posts"><a href="/archives/"><div class="sidebar-state-item-count">3</div><div class="sidebar-state-item-name">归档</div></a></span></div><div class="sidebar-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg" alt="知识共享"></a></div></section></div></aside><div class="content home-content code-highlight"><section class="recent-posts" id="recent-posts"><article class="post"><header class="post-header"><h1 class="post-title"><a class="post-title-link" href="/2019/08/27/topo_sort/">快速入手拓扑排序</a></h1><div class="post-meta"><span class="post-create"><i class="fa fa-calendar-o"></i><span>发表于 </span><span>2019-08-27</span></span><span class="post-update"><i class="fa fa-calendar-check-o"></i><span>更新于 </span><span>2019-08-27</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="快速入手拓扑排序"><a href="#快速入手拓扑排序" class="headerlink" title="快速入手拓扑排序"></a>快速入手拓扑排序</h1><p>[TOC]</p>
<hr>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>​    <strong>在正式讲拓扑排序之前，我们来引入一下，以便各位更好理解。</strong>（所有有向图出品于<span class="external-link"><a href="https://1535608215hr.blog.luogu.org/how-to-use-Xmind" target="_blank" rel="noopener">$Xmind$</a><i class="fa fa-external-link"></i></span>）</p>
<p>​    首先，你想学习计算机的原理怎么办？<del>（白手起家）</del>肯定有很多前置知识啊！流程图就像下面：</p>
<p><img src="https://cdn.luogu.org/upload/pic/49516.png" alt="XMIND"></p>
<p>​    很明显，此时你需要<strong>按一定顺序（这个顺序叫 “拓扑序列”）</strong>学习才能彻底了解计算机原理。那么这个顺序怎么求呢？拓扑排序帮你忙！</p>
<p>​    <strong>前置知识：图的基本概念以及建图编程能力</strong>。</p>
<hr>
<h3 id="2-基本思路-amp-实现"><a href="#2-基本思路-amp-实现" class="headerlink" title="2.基本思路 &amp; 实现"></a>2.基本思路 &amp; 实现</h3><p>​    首先，对于点的关系，大致分为$2$种关系：</p>
<ol>
<li><p>先后关系，如上图的 “数学” 与 “物理学” 的关系。</p>
</li>
<li><p>并列关系（应该叫做“没有关系”），如上图的 ”物理学“ 和 “计算机发展史” 的关系。</p>
<p>不难发现，因为有了并列关系，<strong>拓扑序列不一定是唯一的</strong>。</p>
</li>
</ol>
<p><img src="https://cdn.luogu.org/upload/pic/49519.png" alt></p>
<p>​    如上图，可以得到很多个拓扑序列，这里只举一个例子，其他的相信大家都会看。</p>
<p><code>上图的一个拓扑序列：12345678</code></p>
<p>​    那么大家不难发现，拓扑排序的时候，大家总会找入度为$0$的点，因为这是你不用学习的点，可以直接解锁。</p>
<p>​    找到了之后， 你就可以把这个点放到序列里，那么随之就有新的点的入度为$0$，然后重复上述知道图空。</p>
<p>​    以上就是拓扑排序的基本思路！我们可以简述为：</p>
<blockquote>
<ol>
<li><p>从图中，选择一个入度为$0$的点，并输出该顶点；</p>
</li>
<li><p>从图中，删除该顶点，以及相关联的边；</p>
</li>
<li>重复上述步骤，知道输出所有点。</li>
</ol>
</blockquote>
<p><img src="http://img.mp.itc.cn/upload/20170519/5bc8fb84d3d34554879f9a35d49d8b13.jpg" alt><del>（原来如此简单！）</del></p>
<p>​    下面带大家模拟一遍拓扑排序的过程（大家觉得烦可以跳过）。</p>
<hr>
<h3 id="3-模拟思路"><a href="#3-模拟思路" class="headerlink" title="3. 模拟思路"></a>3. 模拟思路</h3><p><img src="https://cdn.luogu.org/upload/pic/49519.png" alt></p>
<p>​    首先，可以轻易发现，只有点$1$是入度为$0$，因此， 把它输出，删除点$1$和边$A、B$。如下图：</p>
<p><img src="https://cdn.luogu.org/upload/pic/49525.png" alt></p>
<p>​    糟了，有$4$个点的入度为$0$怎么办？</p>
<p>​    不着急，由于<strong>拓扑序列不止一个</strong>的原因，怎样都行，我就按照从小到大来。</p>
<p>​    但是为了加快进度，我们直接删掉$4$个点，并从小到大入拓扑序列，同时删除$H、C、E、F、D、G$六条边！</p>
<p><img src="https://cdn.luogu.org/upload/pic/49526.png" alt></p>
<p>​    现在就很明了啦，把点$6、7$和相关的边删掉，入队，再把点$8$删掉就完工！</p>
<p><code>最终拓扑序列：12345678</code></p>
<p>​    关键来了，怎么用代码实现呢？（其实也不考码力(&gt;_&lt;)啦）</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180901/0cbe21c6aa434ccb9d6eecef30626f02.gif" alt></p>
<hr>
<h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><p>​    拓扑排序一般有三种实现方法（建图是必不可少的）：</p>
<ol>
<li><p>算法设置一个<strong>队列</strong>（方便使用优先队列，从小到大输出）,将所有<strong>入度为$0$的顶点入队</strong>。找入度为$0$的顶点,只要依次出队即可。<strong>删除边的操作转化为将该点关联的所有点的入度减$1$</strong>。此算法有点像$bfs$<del>（我喜欢用这个）</del></p>
</li>
<li><p>类似于$dfs$ 用一个<strong>栈</strong>来存排序后的顺序，从一个顶点开始访问，依次访问它的邻接顶点，回溯的时候将当前结点压入栈。此时入度为$0$的顶点（因为你已经访问过所有邻接顶点）一定是最后压入栈的。</p>
</li>
<li><p>直接用$dfs$搜索各个节点，码量小，时间复杂度只在常数上比上面慢。因此这里不再赘述这种方法。</p>
<p> 现在很明显，由于要改变点的入度，因此我们<strong>需要一个数组保存入度</strong>（核心），并执行相应操作。</p>
</li>
</ol>
<p>​    对于有向无环图，输出升序的拓扑序列的程序（这是舒适的<span class="external-link"><a href="https://www.luogu.org/problemnew/show/U60640" target="_blank" rel="noopener">题面</a><i class="fa fa-external-link"></i></span>）。程序如下（用邻接矩阵和方法$1$）：</p>
<figure class="highlight cpp"><div style="overflow: auto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;<span class="comment">//cnt是为了存储ans数组的下标</span></span><br><span class="line"><span class="keyword">bool</span> a[MAXN][MAXN];<span class="comment">//邻接矩阵建图用</span></span><br><span class="line"><span class="keyword">int</span> indeg[MAXN],ans[MAXN];</span><br><span class="line"><span class="comment">//indeg[i]是第i个点的入度；ans[]是答案队列</span></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		a[x][y]=<span class="number">1</span>;</span><br><span class="line">		indeg[y]++;<span class="comment">//建图，同时统计入度</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo_sort</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	 <span class="keyword">if</span>(indeg[i]==<span class="number">0</span>)</span><br><span class="line">	  q.push(i);<span class="comment">//将所有入度为0的点入队</span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())<span class="comment">//开始搜索</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> u=q.front();</span><br><span class="line">		ans[++cnt]=u;<span class="comment">//入度为0的点记得放到答案队列里</span></span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		 <span class="keyword">if</span>(a[u][i])<span class="comment">//删边的操作转化为入度减1</span></span><br><span class="line">		 &#123;</span><br><span class="line">			indeg[i]--;</span><br><span class="line">			<span class="keyword">if</span>(indeg[i]==<span class="number">0</span>)<span class="comment">//如果这个点变成入度为0，入队列</span></span><br><span class="line">			 q.push(i); </span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sort(ans+<span class="number">1</span>,ans+<span class="number">1</span>+n);<span class="comment">//升序输出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	 <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	input();</span><br><span class="line">	topo_sort();</span><br><span class="line">	output();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>​    此程序时间复杂度显而易见，邻接矩阵时间复杂度$O(n^2)$，。但是用邻接链表的话，由于数据结构不同，时间复杂度$O(n+e)$（忽略$sort()$时间）。一般来说，链表会好些，不过某些时候矩阵更方便表示。</p>
<p>​    用栈实现的拓扑排序也是一样的道理。</p>
<p>​    看到这，应该会有人好奇，为什么不需要$bool$的$visit$数组来标记是否走过这点呢？<del>（你以为是SPFA呢）</del></p>
<p>​    答案是：<strong>不用标记</strong>。因为：（转自@<span class="external-link"><a href="https://www.luogu.org/space/show?uid=145477" target="_blank" rel="noopener">$lyz0$</a><i class="fa fa-external-link"></i></span>讨论帖的一句话）</p>
<blockquote>
<p>在某个结点被弹出队列时，队列中的结点一定不是它的前驱结点，那个结点就一定不会再次入队。</p>
</blockquote>
<p>​    因此，既然节点不会二次入队，所以就不需要$visit$数组啦！同时，也<strong>因为拓扑排序保证每个节点、每条边只被访问过一次，因此时间复杂度是线性的，为$O(n+e)$，而不是$O(ne)$</strong><u>（前提是你用的邻接链表）</u>。</p>
<blockquote>
<p>毕竟一般下，邻接链表还是比邻接矩阵高效。</p>
</blockquote>
<hr>
<p>​    </p>
<p>​    但是你以为放出了程序就结束了吗？当然不是！！！继续观察下面这幅图：</p>
<p><img src="https://cdn.luogu.org/upload/pic/49519.png" alt></p>
<p>​    你可以很明显的发现，拓扑排序的对象只能是个<strong>有向无环图（简称DAG）</strong>！如果有闭环，那么你将没有入度为$0$的点产生，拓扑排序就异常终止……同时，<strong>只要这是个有向无环图，那么它至少有一个拓扑序列</strong>。</p>
<p>​    所以，判断这个图是否有闭环就显得很重要！该如何判断呢……（会的可以跳过）</p>
<p>​    第一种最简单的方法：用拓扑本身。</p>
<p>​    前面说到拓扑排序保证每个节点、每条边只被访问过一次，因此我们只要看一下答案数组存储个数有没有节点数那么多，就可以判断是否有环。有环的话，那么节点就无法入队列，答案数组就会缺。程序如下（代码只多了一个$if$而已）：</p>
<figure class="highlight cpp"><div style="overflow: auto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">bool</span> a[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> indeg[MAXN],ans[MAXN];</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		a[x][y]=<span class="number">1</span>;</span><br><span class="line">		indeg[y]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo_sort</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	 <span class="keyword">if</span>(indeg[i]==<span class="number">0</span>)</span><br><span class="line">	  q.push(i);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> u=q.front();</span><br><span class="line">		ans[++cnt]=u;<span class="comment">//判断环的核心，看答案数组是否有n个</span></span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		 <span class="keyword">if</span>(a[u][i])</span><br><span class="line">		 &#123;</span><br><span class="line">			indeg[i]--;</span><br><span class="line">			<span class="keyword">if</span>(indeg[i]==<span class="number">0</span>)</span><br><span class="line">			 q.push(i); </span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cnt&lt;n)<span class="comment">//判断是否有环，答案队列不足即有环</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"有环！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(ans+<span class="number">1</span>,ans+<span class="number">1</span>+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	 <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	input();</span><br><span class="line">	topo_sort();</span><br><span class="line">	output();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>​    第二种，用$dfs$。</p>
<p>​    <strong>用一个$int$类型的$visit$数组，标记节点，其中$-1$表示回到自己，产生了环，直接$return$</strong>。否则就继续$dfs$跑一遍这个图，跑完了就没有环。时间复杂度$O(n^2)$。个人建议还是用上面那种比较好，那么这个只是提一提，因为这个比较通俗易懂。</p>
<figure class="highlight cpp"><div style="overflow: auto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">bool</span> a[MAXN][MAXN];<span class="comment">//邻接矩阵建图</span></span><br><span class="line"><span class="keyword">bool</span> flag;<span class="comment">//判断是否有环，有环就true</span></span><br><span class="line"><span class="keyword">int</span> visit[MAXN];<span class="comment">//标记节点，注意是int类型，等会儿会说到</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		a[x][y]=<span class="literal">true</span>;<span class="comment">//建图</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	visit[k]=<span class="number">-1</span>;<span class="comment">//特殊标记</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(visit[i]==<span class="number">0</span> &amp;&amp; a[k][i]==<span class="literal">true</span>)<span class="comment">//当前为访问这个点并且有边</span></span><br><span class="line">		&#123;</span><br><span class="line">			dfs(i);<span class="comment">//继续访问</span></span><br><span class="line">			visit[i]=<span class="number">1</span>;<span class="comment">//标记为1。注意：这里要放在dfs的后面，因为才不会被-1赋值的时候覆盖</span></span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">if</span>(visit[i]==<span class="number">-1</span> &amp;&amp; a[k][i]==<span class="literal">true</span>)<span class="comment">//如果回到了自己本身（这就是-1的用处），证明有环</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"有环！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			flag=<span class="literal">true</span>;<span class="comment">//标记输出的</span></span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">//有环可以直接跳出</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">   <span class="comment">//重点还是要区分1和-1的赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	input();</span><br><span class="line">	dfs(<span class="number">1</span>);<span class="comment">//从起点开始，视情况而变</span></span><br><span class="line">	<span class="keyword">if</span>(!flag)<span class="comment">//flag的用处，标记输出</span></span><br><span class="line">	 <span class="built_in">cout</span>&lt;&lt;<span class="string">"无环！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>​    其他判断闭环的方法，大家可以自行百度更优做法。（听说并查集可以）</p>
<hr>
<h3 id="5-洛谷里的例题"><a href="#5-洛谷里的例题" class="headerlink" title="5. 洛谷里的例题"></a>5. 洛谷里的例题</h3><p>​    值得一提的是，<strong>拓扑排序通常都不单独出</strong>，而是配合其他算法综合考察。拓扑排序很多时候是个<strong>辅助</strong>$AK$图论题的好帮手。给出下面几道例题大家刷刷吧。</p>
<p><span class="external-link"><a href="https://www.luogu.org/problemnew/show/P4017" target="_blank" rel="noopener">P4017 最大食物链计数</a><i class="fa fa-external-link"></i></span>：一道比较简单的题目，适合新手练。</p>
<p><span class="external-link"><a href="https://www.luogu.org/problemnew/show/P1038" target="_blank" rel="noopener">P1038 神经网络</a><i class="fa fa-external-link"></i></span>：拓扑排序比较经典题目<del>（我们学校OJ也有）</del>。</p>
<p><span class="external-link"><a href="https://www.luogu.org/problemnew/show/P1983" target="_blank" rel="noopener">P1983 车站分级</a><i class="fa fa-external-link"></i></span>：$NOIp$压轴题，拓扑排序+递推，值得一刷，练练思维。</p>
<p><span class="external-link"><a href="https://www.luogu.org/problemnew/solution/P1137" target="_blank" rel="noopener">P1137 旅行计划</a><i class="fa fa-external-link"></i></span>：拓扑排序+$DP$。<strong>这里只讲讲这道题目如何运用拓扑</strong>（可以进<span class="external-link"><a href="https://1535608215hr.blog.luogu.org/solution-p1137" target="_blank" rel="noopener">blog</a><i class="fa fa-external-link"></i></span>里看题解）。</p>
<p><span class="external-link"><a href="https://www.luogu.org/problemnew/show/P3243" target="_blank" rel="noopener">P3243 [HNOI2015]菜肴制作</a><i class="fa fa-external-link"></i></span>：有思维难度的拓扑排序，但正解也是恍然大悟，一点就通，值得一刷。</p>
<hr>
<h4 id="题解【P1137-旅行计划】"><a href="#题解【P1137-旅行计划】" class="headerlink" title="题解【P1137 旅行计划】"></a>题解【P1137 旅行计划】</h4><p>​    这道题目大家一看就能发现，只能往东边走，并且有个入度为$0$的起点，因此这是一个有向无环图，可以进行拓扑排序，求出拓扑序列。</p>
<p>​    那么我们要拓扑序列怎么做呢？由于拓扑序列中，前面的点总是后面的点的前驱，因此可以进行$dp$。</p>
<p>​    而$dp$式子也很明显，这个城市的路线只能由前面的城市过来（这也像拓扑），因此跟自己与前面城市路线$+1 max$一下，答案就出来。</p>
<p>​    当然，为了效率与内存，最好使用邻接链表（建图就不说了）。</p>
<p>​    具体看注释，参考程序如下：</p>
<figure class="highlight cpp"><div style="overflow: auto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">int</span> indeg[MAXN],f[MAXN],a[MAXN];</span><br><span class="line"><span class="comment">//三个数组分别表示：入度、dp数组、拓扑序列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x,<span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[++sum].next=head[x];</span><br><span class="line">	edge[sum].to=y;</span><br><span class="line">	head[x]=sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">		add(x,y);</span><br><span class="line">		indeg[y]++;<span class="comment">//统计入度</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo_sort</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//按上面教程说得来就行了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	 <span class="keyword">if</span>(!indeg[i])<span class="comment">//初始化队列</span></span><br><span class="line">	  q.push(i);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> tmp=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		a[++cnt]=tmp;<span class="comment">//把队列里的入度为0的点存进拓扑序列</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[tmp];i!=<span class="number">0</span>;i=edge[i].next)<span class="comment">//遍历一遍图</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">int</span> now=edge[i].to;</span><br><span class="line">			indeg[now]--;</span><br><span class="line">			<span class="keyword">if</span>(!indeg[now])</span><br><span class="line">			 q.push(now);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	 f[i]=<span class="number">1</span>;<span class="comment">//每个城市到本身都至少有1条路线</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//每个城市都遍历一遍</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> tmp=a[i];<span class="comment">//注意遍历的是拓扑序列里的城市，此时保证tmp是now的前驱</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=head[tmp];j!=<span class="number">0</span>;j=edge[j].next)<span class="comment">//遍历图</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">int</span> now=edge[j].to;</span><br><span class="line">			f[now]=max(f[now],f[tmp]+<span class="number">1</span>);<span class="comment">//把有关联的城市都max一下</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	input();</span><br><span class="line">	topo_sort();</span><br><span class="line">	dp();</span><br><span class="line">	output();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<hr>
<h3 id="6-参考文献与鸣谢"><a href="#6-参考文献与鸣谢" class="headerlink" title="6. 参考文献与鸣谢"></a>6. 参考文献与鸣谢</h3><ol>
<li>感谢@<span class="external-link"><a href="https://me.csdn.net/u014634338" target="_blank" rel="noopener">zthgreat</a><i class="fa fa-external-link"></i></span>的一篇<span class="external-link"><a href="https://blog.csdn.net/u014634338/article/details/40857015" target="_blank" rel="noopener">博客</a><i class="fa fa-external-link"></i></span>；</li>
<li>感谢@<span class="external-link"><a href="https://www.cnblogs.com/tonghao/" target="_blank" rel="noopener">非我非非我</a><i class="fa fa-external-link"></i></span>的一篇<span class="external-link"><a href="https://www.cnblogs.com/tonghao/p/4721072.html" target="_blank" rel="noopener">博客</a><i class="fa fa-external-link"></i></span>；</li>
<li>感谢@<span class="external-link"><a href="https://blog.csdn.net/qq_26704711" target="_blank" rel="noopener">Tartarusi</a><i class="fa fa-external-link"></i></span>的一篇<span class="external-link"><a href="https://blog.csdn.net/qq_26704711/article/details/79176404" target="_blank" rel="noopener">博客</a><i class="fa fa-external-link"></i></span>；</li>
<li>感谢@<span class="external-link"><a href="https://www.luogu.org/space/show?uid=2699" target="_blank" rel="noopener">Ufowoqqqo</a><i class="fa fa-external-link"></i></span>以前的指导；</li>
<li>感谢<span class="external-link"><a href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/5223807?fr=aladdin#1" target="_blank" rel="noopener">度娘</a><i class="fa fa-external-link"></i></span>……</li>
</ol>
</div></div></article><article class="post"><header class="post-header"><h1 class="post-title"><a class="post-title-link" href="/2019/08/26/test/">TEST</a></h1><div class="post-meta"><span class="post-create"><i class="fa fa-calendar-o"></i><span>发表于 </span><span>2019-08-26</span></span><span class="post-update"><i class="fa fa-calendar-check-o"></i><span>更新于 </span><span>2019-08-27</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h1></div><div class="post-btn"><a href="/2019/08/26/test/">阅读全文 »</a></div></div></article><article class="post"><header class="post-header"><h1 class="post-title"><a class="post-title-link" href="/2019/08/26/hello-world/">Hello World</a></h1><div class="post-meta"><span class="post-create"><i class="fa fa-calendar-o"></i><span>发表于 </span><span>2019-08-26</span></span><span class="post-update"><i class="fa fa-calendar-check-o"></i><span>更新于 </span><span>2019-08-27</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Welcome to <span class="external-link"><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a><i class="fa fa-external-link"></i></span>! This is your very first post. Check <span class="external-link"><a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a><i class="fa fa-external-link"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="external-link"><a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a><i class="fa fa-external-link"></i></span> or you can ask me on <span class="external-link"><a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a><i class="fa fa-external-link"></i></span>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><div style="overflow: auto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></div></figure>
<p>More info: <span class="external-link"><a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><i class="fa fa-external-link"></i></span></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><div style="overflow: auto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></div></figure>
<p>More info: <span class="external-link"><a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a><i class="fa fa-external-link"></i></span></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><div style="overflow: auto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure>
<p>More info: <span class="external-link"><a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a><i class="fa fa-external-link"></i></span></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><div style="overflow: auto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure>
<p>More info: <span class="external-link"><a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a><i class="fa fa-external-link"></i></span></p>
</div></div></article></section><nav id="paginator"><div class="paginator-inner"><span class="page-number current">1</span></div></nav></div><div class="clearfix"></div></div></main><footer id="footer"><div class="footer-inner"><div><span>&copy; 2019</span><span class="fa fa-heart heart-beat footer-separator" style="color: #ff0000"></span><span>HyyypRtf06.</span></div><div><span class="footer-powered">由 <a href="http://hexo.io/" title="hexo" target="_blank" rel="noopener">hexo</a> 强力驱动</span><span> v3.9.0.</span><span class="footer-separator">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="stun" target="_blank" rel="noopener">stun</a></span><span> v1.2.5.</span></div></div></footer><div id="back-top"><div class="back-top-inner" data-popover="回到顶部" data-popover-pos="up"><i class="fa fa-rocket"></i></div></div></div><script>if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
  window.Promise = null;
}
</script><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=1.2.5"></script><script src="/js/stun-boot.js?v=1.2.5"></script><script src="/js/copy.js?v=1.2.5"></script><script src="/js/scroll.js?v=1.2.5"></script><script src="/js/header.js?v=1.2.5"></script><script src="/js/sidebar.js?v=1.2.5"></script></body></html>